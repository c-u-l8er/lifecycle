<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Lifecycle of a Program: A Cosmic Metaphor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background-color: #050505;
      color: #f0f0f0;
      overflow-x: hidden;
    }
    
    #cosmos-container {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }
    
    #stars {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    .star {
      position: absolute;
      background-color: white;
      border-radius: 50%;
    }
    
    #universe {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 2;
    }
    
    .singularity {
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, white, #4a00e0);
      border-radius: 50%;
      box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.5);
    }
    
    .expanding {
      width: 300px;
      height: 300px;
      background-color: transparent;
      border-radius: 50%;
      box-shadow: 0 0 40px 20px rgba(74, 0, 224, 0.3);
    }
    
    .node {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #4af7ff;
      border-radius: 50%;
      box-shadow: 0 0 5px 2px rgba(74, 247, 255, 0.7);
      transition: all 0.5s ease;
    }
    
    .connection {
      position: absolute;
      height: 1px;
      background-color: rgba(74, 247, 255, 0.3);
      transform-origin: left center;
      z-index: -1;
    }
    
    .message {
      position: absolute;
      width: 4px;
      height: 4px;
      background-color: #ffda4a;
      border-radius: 50%;
      z-index: 3;
    }
    
    .dying {
      opacity: 0.5;
      background-color: #ff4a4a;
      box-shadow: 0 0 5px 2px rgba(255, 74, 74, 0.7);
    }
    
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 10;
    }
    
    button {
      background-color: rgba(74, 0, 224, 0.3);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: all 0.3s ease;
    }
    
    button:hover {
      background-color: rgba(74, 0, 224, 0.6);
    }
    
    button:disabled {
      background-color: rgba(50, 50, 50, 0.3);
      cursor: not-allowed;
    }
    
    #log-container {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 300px;
      height: 200px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 10px;
      overflow-y: auto;
      font-size: 12px;
      z-index: 10;
    }
    
    .log-entry {
      margin-bottom: 5px;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .log-timestamp {
      color: #4af7ff;
      margin-right: 5px;
    }
    
    #narrative {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 300px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 15px;
      z-index: 10;
    }
    
    #narrative h2 {
      margin-bottom: 10px;
      color: #4af7ff;
    }
    
    #narrative p {
      margin-bottom: 15px;
      line-height: 1.5;
    }
    
    #cap-status {
      position: absolute;
      bottom: 80px;
      left: 20px;
      width: 300px;
      background-color: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 15px;
      z-index: 10;
    }
    
    .status-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .status-label {
      color: #4af7ff;
    }
    
    .status-value {
      color: #ffda4a;
    }
    
    .status-optimal {
      color: #4aff4a;
    }
    
    .status-degraded {
      color: #ff4a4a;
    }
  </style>
</head>
<body>
  <div id="cosmos-container">
    <div id="stars"></div>
    <div id="universe" class="singularity"></div>
    
    <div id="narrative">
      <h2>The Lifecycle of a Program</h2>
      <p>In the beginning, there was a single function - a singularity containing all potential.</p>
    </div>
    
    <div id="cap-status">
      <div class="status-item">
        <span class="status-label">Phase:</span>
        <span class="status-value" id="phase-status">Singularity</span>
      </div>
      <div class="status-item">
        <span class="status-label">Consistency:</span>
        <span class="status-value status-optimal" id="consistency-status">Perfect</span>
      </div>
      <div class="status-item">
        <span class="status-label">Availability:</span>
        <span class="status-value status-optimal" id="availability-status">Perfect</span>
      </div>
      <div class="status-item">
        <span class="status-label">Partition Tolerance:</span>
        <span class="status-value" id="partition-status">N/A</span>
      </div>
    </div>
    
    <div id="log-container"></div>
    
    <div id="controls">
      <button id="start-btn">Begin Cosmic Cycle</button>
      <button id="expand-btn" disabled>Expand Universe</button>
      <button id="partition-btn" disabled>Create Partition</button>
      <button id="entropy-btn" disabled>Increase Entropy</button>
      <button id="reset-btn" disabled>Reset Universe</button>
    </div>
  </div>

  <script>
    // Universe state
    const universeState = {
      phase: 'singularity',
      nodes: [],
      connections: [],
      messages: [],
      partitions: [],
      log: [],
      consistency: 'perfect',
      availability: 'perfect',
      partitionTolerance: 'n/a'
    };
    
    // DOM elements
    const universeEl = document.getElementById('universe');
    const narrativeEl = document.getElementById('narrative').querySelector('p');
    const logContainerEl = document.getElementById('log-container');
    const startBtn = document.getElementById('start-btn');
    const expandBtn = document.getElementById('expand-btn');
    const partitionBtn = document.getElementById('partition-btn');
    const entropyBtn = document.getElementById('entropy-btn');
    const resetBtn = document.getElementById('reset-btn');
    const phaseStatusEl = document.getElementById('phase-status');
    const consistencyStatusEl = document.getElementById('consistency-status');
    const availabilityStatusEl = document.getElementById('availability-status');
    const partitionStatusEl = document.getElementById('partition-status');
    
    // Create stars background
    function createStars() {
      const starsContainer = document.getElementById('stars');
      const numStars = 200;
      
      for (let i = 0; i < numStars; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        
        // Random position
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        
        // Random size
        const size = Math.random() * 2;
        
        star.style.left = `${x}%`;
        star.style.top = `${y}%`;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.opacity = Math.random();
        
        starsContainer.appendChild(star);
      }
    }
    
    // Add log entry
    function logEvent(event) {
      const timestamp = new Date().toLocaleTimeString();
      universeState.log.push({ timestamp, event });
      
      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry';
      
      const logTimestamp = document.createElement('span');
      logTimestamp.className = 'log-timestamp';
      logTimestamp.textContent = timestamp;
      
      logEntry.appendChild(logTimestamp);
      logEntry.appendChild(document.createTextNode(event));
      
      logContainerEl.appendChild(logEntry);
      logContainerEl.scrollTop = logContainerEl.scrollHeight;
      
      // Freeze the log entry (metaphorically making it immutable)
      Object.freeze(universeState.log[universeState.log.length - 1]);
    }
    
    // Update CAP theorem status display
    function updateCapStatus() {
      phaseStatusEl.textContent = universeState.phase.charAt(0).toUpperCase() + universeState.phase.slice(1);
      consistencyStatusEl.textContent = universeState.consistency;
      availabilityStatusEl.textContent = universeState.availability;
      partitionStatusEl.textContent = universeState.partitionTolerance;
      
      // Update status colors
      consistencyStatusEl.className = 'status-value ' + 
        (universeState.consistency === 'perfect' ? 'status-optimal' : 'status-degraded');
      availabilityStatusEl.className = 'status-value ' + 
        (universeState.availability === 'perfect' ? 'status-optimal' : 'status-degraded');
    }
    
    // Create a node
    function createNode(id, x, y) {
      const node = {
        id,
        x,
        y,
        element: document.createElement('div'),
        connections: [],
        active: true
      };
      
      node.element.className = 'node';
      node.element.style.left = `${x}%`;
      node.element.style.top = `${y}%`;
      node.element.title = `Node ${id}`;
      
      universeEl.appendChild(node.element);
      universeState.nodes.push(node);
      
      return node;
    }
    
    // Create a connection between nodes
    function createConnection(sourceNode, targetNode) {
      const connection = {
        source: sourceNode,
        target: targetNode,
        element: document.createElement('div')
      };
      
      connection.element.className = 'connection';
      
      // Calculate position and dimensions
      const sourceX = sourceNode.x;
      const sourceY = sourceNode.y;
      const targetX = targetNode.x;
      const targetY = targetNode.y;
      
      // Calculate distance and angle
      const dx = targetX - sourceX;
      const dy = targetY - sourceY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      // Set position and dimensions
      connection.element.style.width = `${distance}%`;
      connection.element.style.left = `${sourceX}%`;
      connection.element.style.top = `${sourceY}%`;
      connection.element.style.transform = `rotate(${angle}deg)`;
      
      universeEl.appendChild(connection.element);
      universeState.connections.push(connection);
      
      // Add connection to nodes
      sourceNode.connections.push(connection);
      targetNode.connections.push(connection);
      
      return connection;
    }
    
    // Send a message between nodes
    function sendMessage(sourceNode, targetNode) {
      if (!sourceNode.active || !targetNode.active) return null;
      
      const message = {
        source: sourceNode,
        target: targetNode,
        element: document.createElement('div'),
        delivered: false
      };
      
      message.element.className = 'message';
      message.element.style.left = `${sourceNode.x}%`;
      message.element.style.top = `${sourceNode.y}%`;
      
      universeEl.appendChild(message.element);
      universeState.messages.push(message);
      
      // Animate message
      const duration = 500 + Math.random() * 500; // Varying transmission speeds
      
      setTimeout(() => {
        message.element.style.left = `${targetNode.x}%`;
        message.element.style.top = `${targetNode.y}%`;
        message.element.style.transition = `all ${duration}ms ease`;
        
        setTimeout(() => {
          // Check if target is still active when message arrives
          if (targetNode.active) {
            message.delivered = true;
            
            // Remove message element after delivery
            setTimeout(() => {
              message.element.remove();
              
              // Remove message from array
              const index = universeState.messages.findIndex(m => m === message);
              if (index !== -1) universeState.messages.splice(index, 1);
            }, 300);
          } else {
            // Message failed to deliver
            logEvent(`Message failed to deliver to Node ${targetNode.id} - node unavailable`);
            message.element.remove();
            
            // Remove message from array
            const index = universeState.messages.findIndex(m => m === message);
            if (index !== -1) universeState.messages.splice(index, 1);
          }
        }, duration);
      }, 10);
      
      return message;
    }
    
    // Create a partition that affects some nodes
    function createPartition() {
      const partitionId = universeState.partitions.length + 1;
      const affectedNodes = [];
      
      // Randomly select affected nodes
      universeState.nodes.forEach(node => {
        if (Math.random() > 0.5) {
          affectedNodes.push(node);
          
          // Visually show partition
          node.element.style.boxShadow = '0 0 5px 2px rgba(255, 74, 74, 0.7)';
        }
      });
      
      const partition = {
        id: partitionId,
        affectedNodes,
        active: true
      };
      
      universeState.partitions.push(partition);
      universeState.consistency = 'degraded';
      universeState.partitionTolerance = 'active';
      updateCapStatus();
      
      logEvent(`Partition ${partitionId} created, affecting ${affectedNodes.length} nodes`);
      
      return partition;
    }
    
    // Heal a partition
    function healPartition(partition) {
      // Reset visual indicators
      partition.affectedNodes.forEach(node => {
        if (node.active) {
          node.element.style.boxShadow = '0 0 5px 2px rgba(74, 247, 255, 0.7)';
        }
      });
      
      partition.active = false;
      
      // If no active partitions remain, consistency can improve
      const activePartitions = universeState.partitions.filter(p => p.active);
      if (activePartitions.length === 0) {
        universeState.consistency = 'eventual';
        universeState.partitionTolerance = 'healed';
        updateCapStatus();
      }
      
      logEvent(`Partition ${partition.id} healed`);
    }
    
    // Make a node unavailable
    function makeNodeUnavailable(node) {
      node.active = false;
      node.element.classList.add('dying');
      
      // Update availability status
      const activeNodes = universeState.nodes.filter(n => n.active);
      const availabilityRatio = activeNodes.length / universeState.nodes.length;
      
      if (availabilityRatio <= 0.5) {
        universeState.availability = 'degraded';
      } else if (availabilityRatio < 1) {
        universeState.availability = 'partial';
      }
      
      updateCapStatus();
      
      logEvent(`Node ${node.id} became unavailable`);
    }
    
    // Start the universe (singularity phase)
    function startUniverse() {
      logEvent('Universe initialized from singularity function');
      narrativeEl.textContent = 'In the beginning, there was a single function - a singularity containing all potential.';
      
      // Enable expand button
      expandBtn.disabled = false;
      startBtn.disabled = true;
    }
    
    // Expand the universe (distributed system phase)
    function expandUniverse() {
      universeState.phase = 'expanding';
      updateCapStatus();
      
      universeEl.className = 'expanding';
      logEvent('Universe expanding into distributed system');
      narrativeEl.textContent = 'The singularity expands, creating a complex system of nodes, connections, and messages. The CAP theorem constraints emerge.';
      
      // Create nodes with random positions
      const nodeCount = 10;
      for (let i = 0; i < nodeCount; i++) {
        // Position within the circular bounds (using polar coordinates for even distribution)
        const angle = (i / nodeCount) * Math.PI * 2;
        const distance = 30 + Math.random() * 10; // Distance from center (30-40%)
        
        const x = 50 + Math.cos(angle) * distance;
        const y = 50 + Math.sin(angle) * distance;
        
        const node = createNode(i + 1, x, y);
        logEvent(`Node ${i + 1} created`);
      }
      
      // Create connections between nodes
      for (let i = 0; i < universeState.nodes.length; i++) {
        const sourceNode = universeState.nodes[i];
        
        // Connect to several random nodes
        const connectionCount = 2 + Math.floor(Math.random() * 3); // 2-4 connections
        
        for (let j = 0; j < connectionCount; j++) {
          // Select a random target node that isn't already connected
          const availableTargets = universeState.nodes.filter(node => 
            node !== sourceNode && 
            !sourceNode.connections.some(conn => conn.target === node || conn.source === node)
          );
          
          if (availableTargets.length > 0) {
            const targetIndex = Math.floor(Math.random() * availableTargets.length);
            const targetNode = availableTargets[targetIndex];
            
            createConnection(sourceNode, targetNode);
          }
        }
      }
      
      // Start message passing simulation
      startMessagePassing();
      
      // Enable partition and entropy buttons
      partitionBtn.disabled = false;
      entropyBtn.disabled = false;
      expandBtn.disabled = true;
    }
    
    // Simulate message passing between nodes
    function startMessagePassing() {
      const messageInterval = setInterval(() => {
        // Stop if no active nodes or in heat death phase
        if (universeState.phase === 'heat-death' || universeState.nodes.filter(n => n.active).length < 2) {
          clearInterval(messageInterval);
          return;
        }
        
        // Select random active source node
        const activeNodes = universeState.nodes.filter(n => n.active);
        if (activeNodes.length < 2) return;
        
        const sourceIndex = Math.floor(Math.random() * activeNodes.length);
        const sourceNode = activeNodes[sourceIndex];
        
        // Find active connected nodes
        const connectedNodes = universeState.nodes.filter(node => 
          node !== sourceNode && 
          node.active && 
          sourceNode.connections.some(conn => 
            (conn.source === node || conn.target === node) &&
            !universeState.partitions.some(p => 
              p.active && 
              p.affectedNodes.includes(sourceNode) && 
              p.affectedNodes.includes(node)
            )
          )
        );
        
        if (connectedNodes.length > 0) {
          const targetIndex = Math.floor(Math.random() * connectedNodes.length);
          const targetNode = connectedNodes[targetIndex];
          
          sendMessage(sourceNode, targetNode);
        }
      }, 500);
    }
    
    // Begin the heat death of the universe
    function startHeatDeath() {
      universeState.phase = 'heat-death';
      updateCapStatus();
      
      logEvent('Universe approaching maximum entropy');
      narrativeEl.textContent = 'Energy disperses. The system winds down toward heat death as nodes gradually cease operations. Eventually, only silence remains.';
      
      // Gradually make nodes unavailable
      const nodeCount = universeState.nodes.length;
      let remainingNodes = nodeCount;
      
      universeState.consistency = 'failing';
      universeState.availability = 'degraded';
      universeState.partitionTolerance = 'irrelevant';
      updateCapStatus();
      
      const entropyInterval = setInterval(() => {
        if (remainingNodes <= 0) {
          clearInterval(entropyInterval);
          logEvent('Heat death complete. Universe has reached maximum entropy.');
          
          // Allow reset
          resetBtn.disabled = false;
          entropyBtn.disabled = true;
          partitionBtn.disabled = true;
          
          // Final narrative
          setTimeout(() => {
            narrativeEl.textContent = 'The universe has reached maximum entropy. But perhaps, in this silence, a quantum fluctuation may give rise to a new beginning...';
          }, 2000);
          
          return;
        }
        
        // Find a random active node
        const activeNodes = universeState.nodes.filter(n => n.active);
        if (activeNodes.length === 0) {
          clearInterval(entropyInterval);
          return;
        }
        
        const randomIndex = Math.floor(Math.random() * activeNodes.length);
        const nodeToRemove = activeNodes[randomIndex];
        
        makeNodeUnavailable(nodeToRemove);
        remainingNodes--;
        
        // Log milestones
        if (remainingNodes === Math.floor(nodeCount / 2)) {
          logEvent('Half of all nodes unavailable. System degrading rapidly.');
        }
        
        if (remainingNodes === 1) {
          logEvent('Final node remains. System returning to singularity state.');
        }
      }, 1000);
    }
    
    // Reset the universe
    function resetUniverse() {
      // Clear the universe
      while (universeEl.firstChild) {
        universeEl.removeChild(universeEl.firstChild);
      }
      
      // Reset state
      universeState.phase = 'singularity';
      universeState.nodes = [];
      universeState.connections = [];
      universeState.messages = [];
      universeState.partitions = [];
      universeState.consistency = 'perfect';
      universeState.availability = 'perfect';
      universeState.partitionTolerance = 'n/a';
      updateCapStatus();
      
      // Reset appearance
      universeEl.className = 'singularity';
      
      // Reset buttons
      startBtn.disabled = false;
      expandBtn.disabled = true;
      partitionBtn.disabled = true;
      entropyBtn.disabled = true;
      resetBtn.disabled = true;
      
      // Reset narrative
      narrativeEl.textContent = 'In the beginning, there was a single function - a singularity containing all potential.';
      
      logEvent('Universe reset to initial singularity state');
      logEvent('The patterns repeat, yet each cycle is unique');
    }
    
    // Event listeners
    startBtn.addEventListener('click', startUniverse);
    expandBtn.addEventListener('click', expandUniverse);
    partitionBtn.addEventListener('click', () => {
      createPartition();
      
      // Auto-heal after a delay
      setTimeout(() => {
        const latestPartition = universeState.partitions[universeState.partitions.length - 1];
        if (latestPartition && latestPartition.active) {
          healPartition(latestPartition);
        }
      }, 5000);
    });
    entropyBtn.addEventListener('click', startHeatDeath);
    resetBtn.addEventListener('click', resetUniverse);
    
    // Initialize
    createStars();
    updateCapStatus();
  </script>
</body>
</html>